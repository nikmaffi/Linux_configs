#!/bin/bash

new_c_project() {
    PRJ_NAME="$1"
    PRJ_DIR="./$PRJ_NAME"

    shift 1

    # check if project already exists
    if [ ! -d "$PRJ_DIR" ]; then
        # creating project directory structure
        mkdir -p "$PRJ_DIR"/{src,include,bin,obj,tests,lib}

        # creating main.c file
        cat > "$PRJ_DIR/src/main.c" <<EOL
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {


    return 0;
}
EOL

        # creating Makefile
        cat > "$PRJ_DIR/Makefile" <<EOL
CC=$NKM_C_COMP
DB=$NKM_CCPP_DB

ARCH=64

CFLAGS=-m\$(ARCH) -std=c23 -pedantic -Wvla -Wall -Wextra -funsigned-char -I\$(INCLUDE_DIR)
DEBUG_FLAGS=-g\$(DB) -DDEBUG -fsanitize=address
RELEASE_FLAGS=-O2 -DNDEBUG

SRC_DIR=src
OBJ_DIR=obj
BIN_DIR=bin
INCLUDE_DIR=include

SRCS=\$(wildcard \$(SRC_DIR)/*.c)
OBJS=\$(patsubst \$(SRC_DIR)/%.c, \$(OBJ_DIR)/%.o, \$(SRCS))
LIBS=

BIN=\$(BIN_DIR)/$PRJ_NAME

all: debug

\$(OBJ_DIR):
	mkdir -p $@

\$(BIN_DIR):
	mkdir -p $@

\$(OBJ_DIR)/%.o: \$(SRC_DIR)/%.c | \$(OBJ_DIR)
	\$(CC) \$(CFLAGS) -c \$< -o \$@

\$(BIN): \$(OBJS) | \$(BIN_DIR)
	\$(CC) \$(CFLAGS) \$^ -o \$@ \$(LIBS)

debug: CFLAGS+=\$(DEBUG_FLAGS)
debug: \$(BIN)

release: CFLAGS+=\$(RELEASE_FLAGS)
release: clean \$(BIN)
	strip \$(BIN)

run: all
	./\$(BIN)

clean:
	rm -rf \$(OBJ_DIR)/* \$(BIN_DIR)/*
EOL

        echo "Project '$PRJ_NAME' successfully created!"
    fi

    # creating modules
    if [ "$#" -eq 0 ]; then
        exit 0
    fi

    for module in "$@"; do
        if [ -f "$PRJ_DIR/include/$module.h" ]; then
            echo "Warning: Module '$module' already exists!"
            continue
        fi

        cat > "$PRJ_DIR/include/$module.h" << EOL
#ifndef __${module^^}_H__
#define __${module^^}_H__

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif //__${module^^}_H__
EOL

        cat > "$PRJ_DIR/src/$module.c" << EOL
#include <$module.h>


EOL

        echo "Module '$module' added to $PRJ_NAME!"
    done
}



new_cpp_project() {
    PRJ_NAME="$1"
    PRJ_DIR="./$PRJ_NAME"

    shift 1

    # check if project already exists
    if [ ! -d "$PRJ_DIR" ]; then
        # creating project directory structure
        mkdir -p "$PRJ_DIR"/{src,include,bin,obj,tests,lib}

        # creating main.c file
        cat > "$PRJ_DIR/src/main.cpp" <<EOL
#include <iostream>

int main(int argc, char *argv[]) {


    return 0;
}
EOL

        # creating Makefile
        cat > "$PRJ_DIR/Makefile" <<EOL
CC=$NKM_CPP_COMP
DB=$NKM_CCPP_DB

CFLAGS=-Wall -Wextra -I\$(INCLUDE_DIR)
DEBUG_FLAGS=-g\$(DB) -DDEBUG -fsanitize=address
RELEASE_FLAGS=-O2 -s -DNDEBUG

SRC_DIR=src
OBJ_DIR=obj
BIN_DIR=bin
INCLUDE_DIR=include

SRCS=\$(wildcard \$(SRC_DIR)/*.cpp)
OBJS=\$(patsubst \$(SRC_DIR)/%.cpp, \$(OBJ_DIR)/%.o, \$(SRCS))
LIBS=

BIN=\$(BIN_DIR)/$PRJ_NAME

all: debug

\$(OBJ_DIR)/%.o: \$(SRC_DIR)/%.cpp
	\$(CC) \$(CFLAGS) -c \$< -o \$@

debug: CFLAGS+=\$(DEBUG_FLAGS)
debug: \$(BIN)

release: CFLAGS+=\$(RELEASE_FLAGS)
release: clean
release: \$(BIN)

\$(BIN): \$(OBJS)
	\$(CC) \$(CFLAGS) \$^ -o \$@ \$(LIBS)

clean:
	rm -rf \$(OBJ_DIR)/* \$(BIN_DIR)/*
EOL

        echo "Project '$PRJ_NAME' successfully created!"
    fi

    # creating modules
    if [ "$#" -eq 0 ]; then
        exit 0
    fi

    for module in "$@"; do
        if [ -f "$PRJ_DIR/include/$module.hpp" ]; then
            echo "Warning: Module '$module' already exists!"
            continue
        fi

        cat > "$PRJ_DIR/include/$module.hpp" << EOL
#ifndef __${module^^}_HPP__
#define __${module^^}_HPP__



#endif //__${module^^}_HPP__
EOL

        cat > "$PRJ_DIR/src/$module.cpp" << EOL
#include <$module.hpp>


EOL

        echo "Module '$module' added to $PRJ_NAME!"
    done
}



NKM=$(basename "$0")
NKM_CONFIG="${HOME}/.nkm.conf"
NKM_CONFIG_NR=11

# Checking config file
if [ ! -f "${NKM_CONFIG}" ] || [ $(wc -l < "${NKM_CONFIG}") -ne ${NKM_CONFIG_NR} ]; then
	echo "Please create the configuration file: ${NKM_CONFIG}"

	echo -e "\nConfiguration file specs:
username                       (local and remote)
remote host                    (hostname or ip address)
ssh port                       (22 for default)
local directory to backup      (with '/' at the end)
remote target backup directory (with '/' at the end)
local mount point directory
remote directory to mount
python env to update           ('NULL' for none)
C compiler
C++ compiler
C/C++ debugger"

	exit 1
fi

# Reading config file
IFS= read -r NKM_USERNAME < ${NKM_CONFIG}
NKM_HOME="/home/${NKM_USERNAME}"
IFS= read -r NKM_REMOTE_HOST < <(sed -n '2p' ${NKM_CONFIG})
IFS= read -r NKM_SSH_PORT < <(sed -n '3p' ${NKM_CONFIG})
IFS= read -r NKM_LOCAL_BK_DIR < <(sed -n '4p' ${NKM_CONFIG})
IFS= read -r NKM_REMOTE_BK_DIR < <(sed -n '5p' ${NKM_CONFIG})
IFS= read -r NKM_LOCAL_MOUNT < <(sed -n '6p' ${NKM_CONFIG})
IFS= read -r NKM_REMOTE_MOUNT < <(sed -n '7p' ${NKM_CONFIG})
IFS= read -r NKM_PYTHON_ENV < <(sed -n '8p' ${NKM_CONFIG})
IFS= read -r NKM_C_COMP < <(sed -n '9p' ${NKM_CONFIG})
IFS= read -r NKM_CPP_COMP < <(sed -n '10p' ${NKM_CONFIG})
IFS= read -r NKM_CCPP_DB < <(sed -n '11p' ${NKM_CONFIG})

# Checking number of parameters
if [ $# -lt 1 ]; then
	echo "SYNOPSIS: $NKM {${NKM_REMOTE_HOST}|update|clean|newproj} [OPTIONS]"
    exit 1
fi

if [[ "$1" == "${NKM_REMOTE_HOST}" ]]; then
	# Remote computer actions

	# Checking number of parameters
	if [ $# -lt 2 ]; then
		echo "SYNOPSIS: $NKM $1 {connect|mount|umount|backup-view|backup}"
		exit 1
	fi

	# Switch on second arg
	case "$2" in
		connect)
			echo "Connecting to ${NKM_REMOTE_HOST}..."
			ssh -p "${NKM_SSH_PORT}" "${NKM_USERNAME}"@"${NKM_REMOTE_HOST}"
			;;
		mount)
			echo "Mounting ${NKM_REMOTE_MOUNT} directory..."
			sshfs "${NKM_USERNAME}"@"${NKM_REMOTE_HOST}":"${NKM_REMOTE_MOUNT}" "${NKM_LOCAL_MOUNT}" -p "${NKM_SSH_PORT}"
			;;
		umount)
			echo "Unmounting ${NKM_LOCAL_MOUNT} directory..."
			umount "${NKM_LOCAL_MOUNT}"
			;;
		backup-view)
			echo "Making backup (dry run)..."
			rsync -van --delete --exclude 'env/' -e "ssh -p ${NKM_SSH_PORT}" "${NKM_LOCAL_BK_DIR}" "${NKM_USERNAME}"@"${NKM_REMOTE_HOST}":"${NKM_REMOTE_BK_DIR}"
			;;
		backup)
			echo "Making backup..."
			rsync -va --delete --exclude 'env/' -e "ssh -p ${NKM_SSH_PORT}" "${NKM_LOCAL_BK_DIR}" "${NKM_USERNAME}"@"${NKM_REMOTE_HOST}":"${NKM_REMOTE_BK_DIR}"
			;;
		*)
			echo "Error: '$2' is not an option!"
			exit 1
			;;
	esac
elif [[ "$1" == "update" ]]; then
	# System update action
	echo "Updating the system..."

	# Updating the system
	if command -v pacman &> /dev/null; then
		# Arch-based
		sudo pacman -Syu

		# Updating AUR packages
		if command -v yay &> /dev/null; then
			yay -Syu
		fi
	elif command -v apt &> /dev/null; then
		# Debian-based
		sudo apt update
		sudo apt full-upgrade -y
	elif command -v dnf &> /dev/null; then
		# Fedora
		sudo dnf update -y
	elif command -v rpm-ostree &> /dev/null; then
		# Fedora Silverblue
		rpm-ostree upgrade
	fi

	# Updating flatpak
	if command -v flatpak &> /dev/null; then
		flatpak update
	fi

	# Updating Distrobox
	if command -v distrobox &> /dev/null; then
		# Distrobox upgrade choice
		echo ""
		read -p "Update distrobox? [y/N]: " answ

		if [[ "$answ" == "y" || "$answ" == "Y" ]]; then
			# Updating Distrobox
			distrobox-upgrade --all
		fi
	fi

	# Updating vim plugins (vimplug)
	if command -v vim &> /dev/null; then
		vim -c "PlugUpdate" -c "q" -c "q"
	fi

	# Updating Python env
	if [[ "$NKM_PYTHON_ENV" != "NULL" ]]; then
		# Entering the environment
		source "$NKM_PYTHON_ENV/bin/activate"

		echo -e "\npip packages to update:"

		# Listing packages and updating it
		pip list --outdated
		# pip list --outdated --format=json | python -c "import json, sys; print('\n'.join([x['name'] for x in json.load(sys.stdin)]))" | xargs -n1 pip install -U
		# pip check

		# Exiting the environment
		deactivate
	fi

	# Updating Anaconda
	if command -v conda &> /dev/null; then
		conda update -n base --all
		conda update -n appdev --all
		conda update -n appdev python
	fi
elif [[ "$1" == "clean" ]]; then
	# System clean (package manager)
	echo "Cleaning the system..."
	
	if command -v pacman &> /dev/null; then
		# Removing orphan packages
		sudo pacman -Rns $(sudo pacman -Qqdt)

		# Cleaning pacman cache
		paccache -rk1
	elif command -v apt &> /dev/null; then
		# Removing unused dependencies
		sudo apt autoremove --purge

		# Cleaning apt cache
		sudo apt autoclean
	elif command -v dnf &> /dev/null; then
		# Removing unused dependencies
		sudo dnf autoremove

		# Cleaning dnf cache
		sudo dnf clean packages
	fi

	# Cleaning flatpak
	if command -v flatpak &> /dev/null; then
		flatpak uninstall --delete-data --unused
	fi

	# Cleaning podman
	if command -v podman &> /dev/null; then
		podman image prune -a
		podman volume prune
		podman network prune
	fi

	# Cleaning vim plugins (vimplug)
	if command -v vim &> /dev/null; then
		vim -c "PlugClean" -c "q" -c "q"
	fi

	# Cleaning logs and core dumps
	if command -v journalctl &> /dev/null; then
		sudo journalctl --vacuum-time=1d
		sudo rm /var/lib/systemd/coredump/*
	fi
elif [[ "$1" == "newproj" ]]; then
	# Checking number of parameters
	if [ $# -lt 3 ]; then
		echo "SYNOPSIS: $NKM $1 {c|cpp} PROJECT_NAME [MODULES]"
		exit 1
	fi

	# Switch on second arg
	case "$2" in
		c)
            shift 2
			new_c_project $@
			;;
        cpp)
            shift 2
            new_cpp_project $@
            ;;
		*)
			echo "Error: '$2' is not an option!"
			exit 1
			;;
	esac
else
	echo "Error: '$1' is not an option!"
fi
